%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[hangul]{kotex}

\newenvironment{itemizeReduced}{
\begin{list}{\labelitemi}{\leftmargin=1em}
\setlength{\itemsep}{1pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}}{\end{list}
}

\usepackage{listings}
\usepackage{xcolor}
\lstset{
      language = C++,
      numbers=left,
      stepnumber=1,
      basicstyle=\ttfamily,
      columns=fullflexible,
      breaklines=true,
      postbreak=\mbox{\textcolor{pink}{$\hookrightarrow$}\space}
      escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
      frame=tb, % draw a frame at the top and bottom of the code block
      tabsize=4, % tab space width
      showstringspaces=false, % don't mark spaces in strings
      commentstyle=\color{yellow}, % comment color
      keywordstyle=\color{blue}, % keyword color
      stringstyle=\color{green},
}
\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.13} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
% Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{자료구조 HW3} % Article title
\author{%
\normalsize B711222 \textsc{박조은} \\ % Your name
\normalsize Hongik University \\ % Your institution
\normalsize \href{mailto:mrnglory@mail.hongik.ac.kr}{mrnglory@mail.hongik.ac.kr} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%

}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{List of Source Files}
\begin{itemizeReduced}
\item hw3a
\begin{itemizeReduced}
    \item matrixa.h
    \item matrixa.cpp
    \item hw3a.cpp
    \end{itemizeReduced}
\item hw3b
\begin{itemizeReduced}
    \item matrixb.h
    \item matrixb.cpp
    \item hw3b.cpp
    \end{itemizeReduced}
\end{itemizeReduced}

\section{Reports}
\subsection{연산자 오버로딩의 개념 및 구현방법}
\begin{itemizeReduced}
    \item[/*]
    \item[*] operand 로서 class 의 instance 로 표현해야 할 때, 이를테면 단순히 *this + b 의 형식으로는 원하는 연산을 도출해낼 수 없다.
    \item[*] 따라서 *this 와 b 의 반환값을 각 연산자에 대해 정의 해주어야 하며, 이러한 함수들의 정의는 matrixa.cpp 에서 찾아볼 수 있다.
    \item[*] 이처럼 context 에 걸맞게 기존 operator 를 재사용 하되 새로운 의미를 부여하는 것을 연산자 오버로딩이라고 한다.
\end{itemizeReduced}
*/
\subsection{matrixa.h 와 matrixa.cpp 의 차이점}
\begin{itemizeReduced}
    \item[/*]
    \item[*] matrixa.h 는 hw3a.cpp 와 matrixa.cpp 에서 include 되는 header file 이다.
    \item[*] Matrix 타입의 배열, 즉 각 원소 값들이 초기화 되어 있는 형태의 멤버변수 행렬이 선언되며, 해당 코드에서는 멤버 이니셜라이저의 꼴로 나타나있다.
    \item[*] 또한 연산자 오버로딩에 관한 멤버함수들도 선언 되어있다.
\end{itemizeReduced}
*/\subsection{3 * 3 행렬 함수 구현 중 어려웠던 점}
\begin{itemizeReduced}
    \item[/*] 다음 내용은 3 * 3 행렬 함수 구현에서만 해당 되는 것은 아니다.
    \item[*] 객체 개념에 대해 잘 모른 채로 코드를 작성 해나갈 때, Matrix 행렬명 이런 식으로 객체를 생성 했었다면 return 값으로 일일이 원소들을 나열 할 필요는 없었을 것이다.
    \item[*] 행렬의 곱셈 함수에서 3중 for문을 이용하였는데, 그 결과 값을 출력할 때 index 값의 순서를 헷갈려서 잘 못 적은 것에서 시간이 많이 소요됐었다. 또한 해당 함수 안에서 임의의 행렬을 초기화하지 않아서 원하는 결과가 나타나지 않았었다.
    \item[*] 또한 전치행렬 구현에서, 임의의 배열에 해당 행렬 값을 복사하고 전치한 값을 다시 해당 행렬에 대입하는 과정을 하나의 2중 for 문에서 일괄적으로 처리하려 했었는데, 어려웠던 점 첫 번째 이유와 같은 맥락으로, 임의의 행렬을 선언해놓고 초기화를 하지 않아서 남아있던 쓰레기 값에 의해 전치를 하는 과정에서 원하는 결과가 나타나지 않았었다.
\end{itemizeReduced}
*/%------------------------------------------------

\section{hw3a}

\subsection{matrixa.h}
\begin{lstlisting} [basicstyle=\footnotesize]
#ifndef MATRIX_H
#define MATRIX_H

#include <iostream>

class Matrix
{
public:
        Matrix(int a = 0, int b = 0, int c = 0, int d = 0);
        ~ Matrix() {}

        void ShowMatrix();
        void  Transpose();
        Matrix operator + (const Matrix& a);
        Matrix operator - (const Matrix& a);
        Matrix operator * (const Matrix& a);

        void operator = (const Matrix& a);

private:
        int m[2][2];
};

#endif
\end{lstlisting}
\begin{itemizeReduced}
    \item[/*] 
    \item[*] line 9: Matrix class 의 멤버 이니셜라이저이며, 이를 통한 초기화는 객체 생성 이전에 이루어진다.
    \item[*] line 12 - 13: 멤버함수 선언
    \item[*] line 14 - 16: operator overloading of plus, minus, and multiply
    \item[*] line 18: void 타입의 assignment operator overloading 이다. 별도의 반환값이 존재하지 않는 전치행렬 연산을 위함이다.
    \item[*] line 21: private 타입의 2 /* 2 배열 선언
\end{itemizeReduced}
*/

\subsection{matrixa.cpp}
\begin{lstlisting} [basicstyle=\footnotesize]
#include <iostream>
#include "matrixa.h"
using namespace std;

Matrix::Matrix(int a, int b, int c, int d)
{
        int arr[2][2] = {a, b, c, d};

        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                        m[i][j] = arr[i][j];
}

void Matrix::Transpose()
{
        int arr[2][2];

        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                        arr[i][j] = m[i][j];

        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                        m[i][j] = arr[j][i];
}

Matrix Matrix::operator + (const Matrix &a)
{
        int arr[2][2];

        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                        arr[i][j] = m[i][j] + a.m[i][j];

        return Matrix (arr[0][0], arr[0][1], arr[1][0], arr[1][1]);
}

Matrix Matrix::operator - (const Matrix &a)
{
        int arr[2][2];

        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                        arr[i][j] = m[i][j] - a.m[i][j];

        return Matrix (arr[0][0], arr[0][1], arr[1][0], arr[1][1]);
}

Matrix Matrix::operator * (const Matrix &a)
{
        int arr[2][2] = {0, 0, 0, 0};

        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                        for (int k = 0; k < 2; k++)
                                arr[i][k] += m[i][j] * a.m[j][k];

        return Matrix (arr[0][0], arr[0][1], arr[1][0], arr[1][1]);
}

void Matrix::operator = (const Matrix &a)
{
        for (int i = 0; i < 2; i++)
                for (int j = 0; j < 2; j++)
                                m[i][j] = a.m[i][j];
}

void Matrix::ShowMatrix()
{
        for (int i = 0; i < 2; i++)
        {
                for (int j = 0; j < 2; j++)
                        cout << m[i][j] << " ";
                cout << endl;
        }
}

\newpage

\end{lstlisting}
\begin{itemizeReduced}
    \item[/*] 
    \item[*] line 5: Matrix 객체 생성
    \item[*] line 7: 원소를 임시 배열에 저장한다. 이 때 Matrix a 이런 식으로 선언 했으면 객체를 더 잘 활용했다고 말할 수 있었을 것이다.
    \item[*] line 9 - 11: 입력 받은 Matrix 의 각 원소들을 저장한다.
    \item[*] line 14: *this 의 Transpose 연산을 위한 객체 생성
    \item[*] line 16: 입력 받은 Matrix 값을 복사하기 위한 임시 배열 arr 를 선언한다.
    \item[*] line 18 - 20: 입력 받은 Matrix 값을 임시 배열 arr 에 복사한다.
    \item[*] line 22 - 24: Matrix 값을 들고 있는 배열 arr 를 Transpose 시킨 것을 다시 원래 그 값을 들고 있어야 할 배열에 할당시킨다.
    \item[*] line 27: *this 와 a 의 + 연산 결과 값 반환
    \item[*] line 31 - 33: *this 와 a 의 덧셈 연산
    \item[*] line 35: 결과값을 return 한다.
    \item[*] line 29, 35: 만약 int arr[2][2] 대신 Matrix b 라고 표현 했다면, return b 라고 간단하게 작성할 수 있었을 것이다.
    \item[*] line 38: *this 와 a 의 - 연산 결과 값 반환
    \item[*] line 40 - 46: 위의 plus 구현 코드에서 연산자만 바뀐 것으로, 설명을 생략한다.
    \item[*] line 49: *this 와 a 의 * 연산 결과 값 반환
    \item[*] line 51: 곱셈 연산을 위해 3중 for 문을 실행시키는 과정에서, 각 원소 간의 덧셈 및 곱셈 연산 결과로서 이상한 값이 나오는 것을 방지하기 위해 임시 배열을 초기화하여 쓰레기 값을 제거한다. 
    \item[*] line 53 - 56: 임시 배열에 *this 와 a 의 곱셈 연산 값을 저장한다.
    \item[*] line 58: 해당 값을 반환한다.
    \item[*] line 61: *this 의 assignment 값 저장. return 할 값이 없다.
    \item[*] line 63 - 65: *this 에 a 를 할당한다.
    \item[*] line 68: *this 의 출력
    \item[*] line 70 - 74: *this 의 각 열은 공백으로 구분, 각 행은 개행으로 구분하여 출력한다.
\end{itemizeReduced}
*/

\subsection{hw3a.cpp}
\begin{lstlisting} [basicstyle=\footnotesize]
#include "matrixa.h"
#include <iostream>
using namespace std;

int main()
{
        Matrix matrix1(1, 2, 3, 4);
        Matrix matrix2(1, 1, 1, 1);
        Matrix matrix3;

        cout << "----------------" << endl;
        cout << "Matrix Transpose" << std::endl;
        cout << "----------------" << endl;

        matrix1.Transpose();
        matrix1.ShowMatrix();
        matrix1.Transpose();

        cout << "----------------" << endl;
        cout << "Matrix Add" << endl;
        cout << "----------------" << endl;

        matrix3 = matrix1 + matrix2;
        matrix3.ShowMatrix();

        cout << "----------------" << endl;
        cout << "Matrix Sub" << endl;
        cout << "----------------" << endl;

        matrix3 = matrix1 - matrix2;
        matrix3.ShowMatrix();

        cout << "----------------" << endl;
        cout << "Matrix Multi" << endl;
        cout << "----------------" << endl;

        matrix3 = matrix1 * matrix2;
        matrix3.ShowMatrix();

        cout << "----------------" << endl;

        return 0;
}
\end{lstlisting}
\begin{itemizeReduced}
    \item[/*] 
    \item[*] line 7 - 9: Matrix 타입 matrix1, matrix2, matrix3 생성
    \item[*] line 15 - 17: matrix1 에 대해 Transpose(), ShowMatrix() 함수를 실행시킨다.
    \item[*] line 23 - 24: matrix1 + matrix2 결과를 matrix3 에 저장 및 해당 값 출력
    \item[*] line 30 - 31: matrix1 - matrix2 결과를 matrix3 에 저장 및 해당 값 출력
    \item[*] line 37 - 38: matrix1 * matrix2 결과를 matrix3 에 저장 및 해당 값 출력
    
\end{itemizeReduced}
*/
%------------------------------------------------

\subsection{Results}
\subsubsection{makefile}
\begin{lstlisting} [basicstyle=\footnotesize]
hw3a: hw3a.o matrixa.o
        g++ -o hw3a hw3a.o matrixa.o
hw3a.o matrixa.o: matrixa.h
\end{lstlisting}

\subsubsection{compile}
\begin{lstlisting} [basicstyle=\footnotesize]
[B711222@localhost hw3d]$ ./hw3a
----------------
Matrix Transpose
----------------
1 3
2 4
----------------
Matrix Add
----------------
2 3
4 5
----------------
Matrix Sub
----------------
0 1
2 3
----------------
Matrix Multi
----------------
3 3
7 7
----------------
\end{lstlisting}

\clearpage

\section{hw3b}
\subsection{rectb.h}
\begin{lstlisting} [basicstyle=\footnotesize]
#ifndef MATRIX_H
#define MATRIX_H
#include <iostream>
using namespace std;

class Matrix
{
public:
        Matrix(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0, int g = 0, int h = 0, int i = 0);
        ~ Matrix() {}

        void ShowMatrix();
        void Transpose();
        Matrix operator + (const Matrix& a);
        Matrix operator - (const Matrix& a);
        Matrix operator * (const Matrix& a);

        void operator = (const Matrix& a);

private:
        int m[3][3];
};

#endif
\end{lstlisting}
\begin{itemizeReduced}
    \item[/*] hw3a 와 동일한 부분은 설명을 생략하도록 한다.
    \item[*] line 9: 3 * 3 Matrix 에 대한 멤버 이니셜라이저이므로, 인자의 갯수는 총 9 개이다.
    \item[*] private 타입 멤버 변수가 3 * 3 크기의 배열이다.
\end{itemizeReduced}
*/

\subsection{matrixb.cpp}
\begin{lstlisting} [basicstyle=\footnotesize]
#include <iostream>
#include "matrixb.h"
using namespace std;

Matrix::Matrix(int a, int b, int c, int d, int e, int f, int g, int h, int i)
{
        int arr[3][3] = {a, b, c, d, e, f, g, h, i};

        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                        m[i][j] = arr[i][j];
}

void Matrix::Transpose()
{
        int arr[3][3];

        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                        arr[i][j] = m[i][j];

        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                        m[i][j] = arr[j][i];
}

Matrix Matrix::operator + (const Matrix &a)
{
        int arr[3][3];

        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                        arr[i][j] = m[i][j] + a.m[i][j];

        return Matrix (arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2], arr[2][0], arr[2][1], arr[2][2]);
}

Matrix Matrix::operator - (const Matrix &a)
{
        int arr[3][3];

        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                        arr[i][j] = m[i][j] - a.m[i][j];

        return Matrix (arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2], arr[2][0], arr[2][1], arr[2][2]);

}

Matrix Matrix::operator * (const Matrix &a)
{
        int arr[3][3] = {0, 0, 0, 0, 0, 0, 0, 0, 0};

        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                        for (int k = 0; k < 3; k++)
                                arr[i][k] += m[i][j] * a.m[j][k];

        return Matrix (arr[0][0], arr[0][1], arr[0][2], arr[1][0], arr[1][1], arr[1][2], arr[2][0], arr[2][1], arr[2][2]);

}

void Matrix::operator = (const Matrix &a)
{
        for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                                m[i][j] = a.m[i][j];
}

void Matrix::ShowMatrix()
{
        for (int i = 0; i < 3; i++)
        {
                for (int j = 0; j < 3; j++)
                        cout << m[i][j] << " ";
                cout << endl;
        }
}
\end{lstlisting}
\begin{itemizeReduced}
    \item[/*] hw3a 와 동일한 부분은 설명을 생략하도록 한다.
    \item[*] Matrix 의 크기가 2 * 2 이든 3 * 3 이든, 연산 과정은 동일하다. (배열의 크기 및 반복문 수행 횟수 제외)
\end{itemizeReduced}
*/

\subsection{hw3b.cpp}
\begin{lstlisting} [basicstyle=\footnotesize]
#include "matrixb.h"
#include <iostream>
using namespace std;

int main()
{
        Matrix matrix1(1, 2, 3, 4, 5, 6, 7, 8, 9);
        Matrix matrix2(1, 1, 1, 1, 1, 1, 1, 1, 1);
        Matrix matrix3;

        cout << "----------------" << endl;
        cout << "Matrix Transpose" << std::endl;
        cout << "----------------" << endl;

        matrix1.Transpose();
        matrix1.ShowMatrix();
        matrix1.Transpose();

        cout << "----------------" << endl;
        cout << "Matrix Add" << endl;
        cout << "----------------" << endl;

        matrix3 = matrix1 + matrix2;
        matrix3.ShowMatrix();

        cout << "----------------" << endl;
        cout << "Matrix Sub" << endl;
        cout << "----------------" << endl;

        matrix3 = matrix1 - matrix2;
        matrix3.ShowMatrix();

        cout << "----------------" << endl;
        cout << "Matrix Multi" << endl;
        cout << "----------------" << endl;

        matrix3 = matrix1 * matrix2;
        matrix3.ShowMatrix();

        cout << "----------------" << endl;

        return 0;
}
\end{lstlisting}
\begin{itemizeReduced}
    \item[/*] hw3a 와 동일한 부분은 설명을 생략하도록 한다.
    \item[*] Matrix 의 크기가 2 * 2 이든 3 * 3 이든, 연산 과정은 동일하다. (배열의 크기 및 반복문 수행 횟수 제외)
\end{itemizeReduced}
*/

\subsection{results}
\subsubsection{makefile}
\begin{lstlisting} [basicstyle=\footnotesize]
hw3b: hw3b.o matrixb.o
        g++ -o hw3b hw3b.o matrixb.o
hw3b.o matrixb.o: matrixb.h
\end{lstlisting}

\subsubsection{compile}
\begin{lstlisting} [basicstyle=\footnotesize]
[B711222@localhost hw3d]$ ./hw3b
----------------
Matrix Transpose
----------------
1 4 7
2 5 8
3 6 9
----------------
Matrix Add
----------------
2 3 4
5 6 7
8 9 10
----------------
Matrix Sub
----------------
0 1 2
3 4 5
6 7 8
----------------
Matrix Multi
----------------
6 6 6
15 15 15
24 24 24
----------------
\end{lstlisting}
%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------

\end{document}
